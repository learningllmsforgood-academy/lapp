- starting the course: https://nextjs.org/learn/foundations/about-nextjs

why njs?
========

- has lego pieces to create fast web applications

things to consider / building blocks in a web app:

1. UI: how users consume info & interact with the app.

2. Routing: navigation between different parts of the app.

3. Data Fetching: where does the src data live and how to get it to the app?

4. Rendering: generate content (html + css) - static / dynamic

5. Integrations: Interface with 3rd party services / APIs. e.g. auth, CMS, payments etc.

6. Infra: where does the app live and how it is deployed - serverless, CDN, edge, etc.

7. Performance: make the app fast for end-user.

8. Scalability: when team / users / data grow, how does the app adapt?

9. Devx (Developer Experience): how is easy it is for devs to build and maintain the app.


For each of these, need to choose:

- build in-house
- use existing libraries / frameworks

--

React.js
========

JS library for building user interfaces.
    -----               ---------------

UI? the element users see and interact with. Mostly on-screen.

both +ve & -ve: very unopinionated.
can lead to a lot of time being spend on configuring tools and reinventing solutions to common app requirements.

Next.js
=======

- Provides structure around React.
- handles tooling and configuration.
- can also adopt next.js incrementally


DOM
====

- Ref / tutorial on dom manipulation using vanilla JS - https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents


Aside - unpkg | umd
===================

- unpkg.com is CDN for any node module.
- best to UMD (universal module definition)
    - what is UMD?
       - https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm#umd
       - https://dontkry.com/posts/code/browserify-and-the-universal-module-definition.html
       - https://github.com/umdjs/umd/



React State
===========

- apart from `useState` React provides a bunch of APIs to manage state. examples:
    - `useReducer`
    - `useContext`

Reference: https://react.dev/learn/managing-state


How Next.js Works
=================

[https://nextjs.org/learn/foundations/how-nextjs-works]

- basics of how next.js works
- react is unopionated about how to build and structure apps.
    - next.js provides this structure.
        - + optimizations to make dev and prod faster
    - key concepts:
        - env where my code runs? :: dev / prod
            - dev
                - optimze for dev experience. comes with
                    - TypeScript
                    - ESLint
                    - Fast Refresh
                    - ...
            - prod
                - optimize for end user experience
                    - transform code to make it more performant
                        - { similar to babel / vite / webpack work }
                            - compile
                            - bundle
                            - minify
                            - split

            - how?
                - next.js compiler
                    - written in Rust
                        - + SWC => what is it?
                            - platform that can be used for:
                                - compilation, minification, bundling, etc.

            - components

                - compilation
                    - transpile Typescript + JSX to JS that can be run on browsers
                        - happens both during dev and prod build
                - minification
                    - remove formatting, indenting, etc.
                    - reduce file size in prod
                - bundling
                    - resolve import / export graph
                    - { create a single bundle.js / app.js containing all the code for the app }
                - code spliting
                    - { 
                        input:  bundle.js
                        output: common.js, page1.js / chunk1.js, page2.js / chunk2.js, etc.
                    }
                    - each file in `pages/` will be split into its own bundle.
                        - code shared between pages is also split into its own
                            bundle to avoid downloading duplicate code
                        - after initial load njs pre loads bundles that are likely to be used
                        - can also control it manually:
                            - dynamic imports.
            
        - when my code runs? :: build time / runtime

            - build time (build step)
                - njs takes code written by devs and transforms it into different files:
                    - static HTML + CSS files
                    - js code file(s) that run on the server {to render the page server side}
                    - js code file(s) that run on the client (browser) {to make the app interactive}
                    

            - runtime (request time)
                - after app has been built and deployed
                    - code that runs on user request
                        - { mostly refers to server side code } 
                        - { similart to serverless functions }


        - where rendering happens? :: client / server
            - client
                - { user's device (brower). send's request to server for app code }
                - { also sends requests to server for data }
            - server
                - { computer that runs in a data center }
                - { stores application code }
                - { request from client => < computation on server > => response to client }

            - what is rendering?
                - { dev react code => < rendering process > => UI HTML }

            - where does rendering take place?
                - both client and server

            - when does rendering take place?
                - both of:
                    1. ahead of time (during the build phase)
                    2. on demand (on every request) (at runtime)

            - types of rendering on next.js
                - server-side rendering (SSR)
                - static site generation (SSG)
                - client-side rendering (CSR)

                -  { SSR + SSG => together called pre-rendering }
                    - why? fetching of external data (server side props)
                        and transformation of React components into HTML
                            happens before request is sent by client
                    - { can be thought of like a caching layer }
                
                - client side rendering
                    - { in classic react: server sends empty HTML "shell" 
                        + JS code (instructions on how to render HTML) }
                        - { rendering happens on user device }
        
                        - next.js also allows for client side rendering:
                            - fetch data using -
                                - >> <b>`useEffect`</b>
                                - >> <b>`useSWR`</b>
                
                - by default: next.js pre-renders every page by default
                    - HTML generated in advance on server
                        - { for blog like content: better for SEO }
                        - { faster initial page renders }
                        - { low time to initial user interactivity }
                
                - pre-render
                    - SSR: Server Side Rendering
                        - HTML generation on server for each request
                            - generated HTML + JSON data { required for hydration }
                                + JS { to make page interactive } sent to client.
                            - hydration: react uses generated json data + JS code
                                to make the interactive, continuing from the same
                                state as the server side generated HTML
                        
                        - >> can opt into SSR by using <b>`getServerSideProps`</b>

                        - NOTE: next 12 + react 18 also include alpha version of <i>React server components</i>
                            - it does not have any client-side js to render
                        
                    - SSG: Static Site Generation
                        - HTML generated, but on each on each request
                            - done ahead of time, during the build phase
                            - generated HTML is stored in a CDN
                                - reused for each request
                            - { sounds much more efficient }
                        
                        - >> can opt to SSG by using <b>`getStaticProps`</b>

                        - can also use <b>Incremental Static Regeneration</b>
                            - can update build static HTML
                            - don't have to do pull rebuild of entire site
                            - kind of like applying deltas

                    - << the next.js advantage >>
                        - can choose the best rendering method on a page-by-page basis
                            - >> read more in the <i>data fetching docs</i>
                    
                    



                     




                - << network >>

                    - components
                        - origin servers
                        - CDNs
                        - Edge

                    - CDN
                        - store static content
                        - geographically distributed
                        - uses benefits of caching
                        
                    - "The Edge"
                        - servers / computers part of the network that are closest to the user
                        - Technically CDNs are also part of "The Edge"
                        - In general Edge servers can also run small snippets of code
                        - Essentially reduces latency
                        - kind of a perf optimization


First Next.js App
================

[https://nextjs.org/learn/basics/create-nextjs-app]

> will create a simple demo blog using next

uses [this](https://github.com/vercel/next-learn/tree/main/basics/learn-starter) as the starter code.

```
npx create-next-app@latest nextjs-blog --use-npm --example "https://github.com/vercel/next-learn/tree/main/basics/learn-starter"
```

Navigating Between Pages
========================

- multi page app
    - "file routing system"
- <Link > component
- code spliting and prefetching

Page? in Next.js
===============

A "page" is just a react component exported from the pages/ directory.

page <=> route association done based on filename

- use `next/Link` component instead of <a>
    - why?
        - allows to do "client-side navigation"
            - client-side navigation actually refers to a bunch of [optimizations](https://nextjs.org/learn/basics/navigate-between-pages/client-side)
                done by next.
    - how?
        - similar to the <a> tag.
            - `<Link href="link-target-here">Link text here</Link>`
    - for external pages use <a> instead of <Link>

Styling
=======

Next has builtin support for CSS and Sass.

[Styling docs](https://nextjs.org/docs/pages/building-your-application/styling)

> adding static files / images
    - put em in top level `public` directory
        - files inside this dir can be referenced from app root


> customize the <head> for each page
> create reusable components styled using CSS Modules
> adding global css
> styling tips

ways of styling:
- sass: `.css` and `.scss` files
- postcss: tailwind
- css in js: styled-jsx, styled-components, emotion
- etc.

> utility 1st CSS: https://tailwindcss.com/docs/utility-first

> more styling tips: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips

notes:
- out of the box next.js compiles css using PostCSS
    - can customize config by creating a top-level `postcss.config.js` file
        > useful if using tailwind
        - [example](https://github.com/vercel/next.js/tree/canary/examples/with-tailwindcss) for getting started with tailwind

Images
======

- Use `next/image` instead of <img>.
    - has a bunch of [optimizations](https://nextjs.org/docs/pages/building-your-application/optimizing/images) built in.

Head
====

[https://nextjs.org/docs/pages/api-reference/components/head]

- note: Head can also contain [Open Graph](https://ogp.me/) (`og:?`) tags
    - these are used to render preview of the page by apps like twitter, slack, etc.
    - refs:
        - https://www.freecodecamp.org/news/what-is-open-graph-and-how-can-i-use-it-for-my-website/
        - https://seosetups.com/blog/open-graph/


3rd Party JS
============

[https://nextjs.org/learn/basics/assets-metadata-css/third-party-javascript]

> next.js [recommends against](https://nextjs.org/docs/messages/no-script-tags-in-head-component) directly include in the head as script tag.
    - should use `next/script` instead.
        - can be used anywhere in the page

_app.js
=======

[https://nextjs.org/docs/pages/building-your-application/routing/custom-app]

- top level component that wraps all pages in the app.
- can be used to:
    - keep state while navigating between pages
    - add global styles


pre-rendering & data fetching
=============================

[https://nextjs.org/docs/pages/building-your-application/data-fetching]

topics:
- next.js pre-rendering feature
    - Static Generation
        - w data
        - wo data
    - Server-side Rendering
- getStaticProps

+ pre-rendering
    - next.js generates HTML for each page
    - so should work page should be viewable even with js disabled
    - by default next will pre-render every page
        - html generation happens in advance
    - better for perf and seo
    - { hydration }

    1. Static Site Generation (ssg)
    2. Server Side Rendering (ssr)

    - in dev next does ssr
        - in prod it defaults to ssg
    - per page basis
        - for each page we can decide
            - ssg vs ssr
            - hybrid app
                - most pages are ssg.
                - some are ssr
    
    - ssg is generally better for perf
        - and benefits from caching at CDN
        - so try to do this whenever possible
        - not good when user / request context is required for rendering
        - ssg with data
            - load data from an external system
            - `getStaticProps`
                - query external system
                - fetch data
                - return props
                - { in dev getStaticProps runs on every request }
                - { in prod runs at build time }
                - { only run server side }
                - { js code is also not shipped to the client }

    - ssr
        - required when need to fetch data at request time
            - instead of build time
        - `getServerSideProps`
            - TTFB (time to first byte) will be slower than `getStaticProps`
                - code will run on the server at each request
            - same interface as `getStaticProps`
                - just when the code runs is different
    
    - client side rendering
        - swr [https://swr.vercel.app/]


Dynamic Routes
==============

[https://nextjs.org/learn/basics/dynamic-routes]

- dynamic urls: `getStaticPaths`
    - `getStaticProps` for each dynamic page
        - documentation: [https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-paths]
        - fallback param docs: [https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-false]
    
    - `[id].js` vs `[...id].js`
        
        - `[id].js` => returned `id` is  string
        
            - for example:
                ```
                `pages/posts/[id].js:getStaticProps` returns {
                    paths: [
                        {
                            params: {
                                id: "a"
                            }
                        },
                        {
                            params: {
                                id: "b"
                            }
                        },
                        {
                            params: {
                                id: "c"
                            }
                        }
                    ]
                }
                ```
                actual paths become something like:
                - `/posts/a`
                - `/posts/a`
                - `/posts/c`

        - `[...id].js` => returned `id` is an array
            
            - for example:
                ```
                `pages/posts/[id].js:getStaticProps` returns {
                    paths: [
                        {
                            params: {
                                id: ["a", "b", "c"]
                            }
                        },
                        {
                            params: {
                                id: ["b", "d"]
                            }
                        },
                    ]
                }
                ```
                actual paths become something like:
                - `/posts/a/b/c`
                - `/posts/b/d`

- link pages using dynamic routes

- advanced
    - [`useRouter`](https://nextjs.org/docs/pages/api-reference/functions/use-router): access the next.js router inside components

    - [Error Pages](https://nextjs.org/docs/pages/building-your-application/routing/custom-error)
        - `pages/404.js` => for custom 404 page

    - [More example](https://nextjs.org/learn-pages-router/basics/dynamic-routes/dynamic-routes-details)
